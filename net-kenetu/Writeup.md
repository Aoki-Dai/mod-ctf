# 検閲を嘲笑う残響 Writeup

## 問題概要

社内ネットワークから外部への不正なデータ送信が検出されました。提供されたパケットキャプチャファイル (`traffic.pcap`) を解析し、フラグを特定する必要があります。

## 解析手順

### 1. プロトコル階層の確認

まず、どのような通信が行われているかを確認するために、`tshark` を使用してプロトコル階層の統計を取りました。

```bash
tshark -r traffic.pcap -z io,phs
```

結果として、多数の ICMP パケット (Echo request/reply) が観測されました。ファイアウォールで基本的な通信が遮断されている環境下では、ICMP トンネリングなどが疑われます。

### 2. ICMP パケットの調査

ICMP Echo Request (Type 8) のデータペイロードを調査しました。
通常、Linux などの `ping` コマンドは `00` から始まる連番のデータをペイロードとして送信します。
標準的なパターン： `000000000000000010111213141516171819...`

パケットを確認すると、この標準パターンと異なるデータを持つパケットが多数存在することがわかりました。

### 3. データの抽出

標準パターンと異なるパケットを詳細に比較すると、**オフセット 0x10 (17バイト目)** の値だけが変更されていることが判明しました。

例：

- 標準: `...1617 18 19...`
- 観測: `...1617 66 19...` -> `0x66` ('f')

この変更されたバイトをキャプチャ順に抽出することで、隠されたメッセージを復元できると推測しました。

### 4. フラグの復元

以下の手法でデータを抽出しました。

1. `tshark` で ICMP Echo Request かつ標準データと一致しないパケットのデータフィールドを抽出。
2. Python スクリプトで各パケットの該当バイト（17バイト目）を文字に変換して連結。

**実行コマンド例:**

```bash
tshark -r traffic.pcap -Y "icmp.type == 8 && data != 00:00:00:00:00:00:00:00:10:11:12:13:14:15:16:17:18:19:1a:1b:1c:1d:1e:1f:20:21:22:23:24:25:26:27:28:29:2a:2b:2c:2d:2e:2f:30:31:32:33:34:35:36:37" -T fields -e data > icmp_data.txt
```

**復元結果:**
抽出された文字を繋げると、以下のフラグが得られました。

**Flag:** `flag{1cmp_c0v3r7_ch4nn3l_15_h1dd3n}`

---

## 解説

- **使われたプロトコル**: ICMP (Internet Control Message Protocol)
- **データの埋め込みについて**: ICMP Echo Request のデータペイロードの一部（1バイト）を書き換えることで、情報を隠蔽して送信する「ICMPトンネリング（covert channel）」の手法が使われていました。
